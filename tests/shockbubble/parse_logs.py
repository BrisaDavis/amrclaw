#!/usr/bin/env python

r"""Parse a log file generated by run_thread_tests.py"""

import sys
import os
import re
import glob
import math
import getopt
    
import matplotlib.pyplot as plt

import run_thread_tests

help_message = r"""
Parse log files generated by run_thread_tests.py

Command line options:
    -v, --verbose - Verbose output (default == False)
    -g, --path=(string) - Path to directory containing log files 
                          (default == LOG_FILE_BASE in run_thread_tests.py)
    -f, --format=(string) - Format of plot output, can be anything that
                            matplotlib can understand (default == 'pdf')
    -F, --force - Force time file parsing
    -h, --help - Display help message
"""

log_regex = re.compile(r"\*{3}\sOMP_NUM_THREADS\s=\s.*|\*{7}\stick\stiming\s=\s+.*\ss{1}")
time_regex = re.compile(r"\*{3}\sOMP_NUM_THREADS\s=\s.*|\s+Elapsed\s\(wall\sclock\).*") # \s+User\stime\s\(seconds\)\:\s.*

def expand_path(path):
    return os.path.expandvars(os.path.expanduser(path))

def parse_log_file(path,verbose=True):
    # Open contents of log file 
    log_contents = open(path,'r').read()
    
    # Loop through regular expression finds
    threads = []
    times = []
    for match in log_regex.finditer(log_contents):
        if "OMP_NUM_THREADS" in match.group():
            threads.append(int(match.group().strip("*** OMP_NUM_THREADS =")))
            if verbose:
                print "Threads = %s" % threads[-1]
        elif "tick timing" in match.group():
            times.append(float(match.group().strip("******* tick timing =")[:-1]))
            if verbose:
                print "Time = %s" % times[-1]
    
    if not len(threads) == len(times):
        print "Parsing may not have been successful, len(threads) != len(times)."
        print "  path = %s" % path
        print "  threads = %s" % threads
        print "  times = %s" % times
        sys.exit(2)
    
    return threads,times

def parse_time_file(path,verbose=True):
    # Open contents of log file
    log_contents = open(path,'r').read()
    
    # Loop through regular expression finds
    threads = []
    times = []
    for match in time_regex.finditer(log_contents):
        if "OMP_NUM_THREADS" in match.group():
            threads.append(int(match.group().strip("*** OMP_NUM_THREADS =")))
            if verbose:
                print "Threads = %s" % threads[-1]
        # This parsing assumes that we never roll over to hours
        elif "Elapsed (wall clock) time" in match.group():
            raw_time = match.group().strip().strip("Elapsed (wall clock) time (h:mm:ss or m:ss): ")
            [minutes,seconds] = raw_time.split(':')
            times.append(float(minutes)*60+float(seconds))
            if verbose:
                print "Time = %s" % times[-1]
        # elif "User time" in match.group():
        #     times.append(float(match.group().strip().strip("User time (seconds): ")))
        #     if verbose:
        #         print "Time = %s" % times[-1]
    
    if not len(threads) == len(times):
        print "Parsing may not have been successful, len(threads) != len(times)."
        print "  path = %s" % path
        print "  threads = %s" % threads
        print "  times = %s" % times
        sys.exit(2)
    
    return threads,times

def create_timing_plots(log_paths,plot_path='./plots',out_format='png',
                                  out_file_base='plot',figsize=(8,6),
                                  single_plot=False,verbose=False):
    
    # Create the directory for the plots if it does not already exist
    if not os.path.exists(plot_path):
        os.makedirs(plot_path)
    if not os.path.isdir(plot_path):
        print >> sys.stderr, "File already exists with the same name as the "
        print >> sys.stderr, "requested plot directory %s." % plot_path
        sys.exit(42)
    
    # AMR data retention
    amr_sweep_threads = []
    amr_sweep_times = []
    amr_grid_threads = []
    amr_grid_times = []
    
    # Go through each log file and parse it
    for (i,path) in enumerate(log_paths):
        # Parse the log file
        if verbose:
            print os.path.basename(path)[:-4]
        if os.path.basename(path)[0:3] == "log":
            log_name = os.path.basename(path).strip('log_')[:-4]
            threads,times = parse_log_file(path,verbose=verbose)
        elif os.path.basename(path)[0:4] == "time":
            log_name = os.path.basename(path).strip('time_')[:-3]
            threads,times = parse_time_file(path,verbose=verbose)
        if verbose:
            print threads,times

        # Save this data if this was an AMR run for later plotting
        if "amr_sweep" in log_name:
            amr_sweep_threads.append(threads)
            amr_sweep_times.append(times)
        elif "amr_grid" in log_name:
            amr_grid_threads.append(threads)
            amr_grid_times.append(times)

        # Plot this run
        fig = plt.figure(figsize=figsize)
        axes = fig.add_subplot(111)
        axes.plot(threads,times,'or-')
        
        # Labeling
        axes.set_xbound(threads[0]-0.5,threads[-1]+0.5)
        axes.set_title(log_name)
        axes.set_xlabel('Number of Threads')
        axes.set_xticks(threads)
        axes.set_xticklabels(threads)
        axes.set_ylabel('Time (s)')

        # Matplotlib version > 1.0 only support tight_layout
        try:
            plt.tight_layout()
        except:
            pass

        if out_format is not None:
            file_name = '%s_%s.%s' % (log_name,out_file_base,out_format)
            if verbose:
                print file_name
                print "Saving plot to %s" % os.path.join(plot_path,file_name)
            plt.savefig(os.path.join(plot_path,file_name))
        else:
            plt.show()
    
    # Plot AMR data on one figure
    if len(amr_grid_threads) > 0:
        fig = plt.figure(figsize=figsize)
        axes = fig.add_subplot(111)
        axes.plot(amr_grid_threads[:],amr_grid_times[:])
        plt.show()
    

class Usage(Exception):
    def __init__(self,msg):
        self.msg = msg   

if __name__ == "__main__":
    # Parse command line arguments
    try:
        try:
            opts,args = getopt.getopt(sys.argv[1:],"hvp:f:F",['help','verbose',
                                            'path=','format=','force'])
        except getopt.error, msg:
            raise Usage(msg)
        
        # Default values
        verbose = False
        log_dir = run_thread_tests.LOG_PATH_BASE
        format = 'pdf'
        force = False
    
        # Option parsing
        for option,value in opts:
            if option in ("-v","--verbose"):
                verbose = True
            if option in ("-p",'--path'):
                log_dir = value
            if option in ('-f','--format'):
                format = value
            if option in ('-F','--force'):
                force = True
            if option in ("-h","--help"):
                raise Usage(help_message)
    except Usage, err:
        print >> sys.stderr, sys.argv[0].split("/")[-1] + ": " + str(err.msg)
        # print >> sys.stderr, "\t for help use --help"
        sys.exit(2)
        
    # Find log files
    log_files = glob.glob(expand_path(os.path.join(log_dir,"log*.txt")))
    if verbose:
        print "Found these log files:"
        print '\t\n'.join(log_files)
    if len(log_files) == 0:
        print >> sys.stderr, "Did not find any log files at:"
        print >> sys.stderr, "\t%s" % log_dir
        sys.exit(2)
        
    # Find and parse all log files found in log_dir
    create_timing_plots(log_files,plot_path='./plots',out_format=format,out_file_base='tick_plot',verbose=verbose)
    
    # Only use the timing files if we are not on Darwin (time does not work as awesome there)
    if not os.uname()[0] == 'Darwin' or force:
        time_files = glob.glob(expand_path(os.path.join(log_dir,"time*.txt")))
        if verbose:
            print "Found these time files:"
            print '\t\n'.join(log_files)
        if len(log_files) == 0:
            print >> sys.stderr, "Did not find any time files at:"
            print >> sys.stderr, "\t%s" % log_dir
            sys.exit(2)
        create_timing_plots(time_files,plot_path='./plots',out_format=format,out_file_base='time_plot',verbose=verbose)

        
