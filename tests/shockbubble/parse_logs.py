#!/usr/bin/env python

r"""Parse a log file generated by run_thread_tests.py"""

import sys
import os
import re
import glob
import math

log_regex = re.compile(r"\*{7}\stick\stiming\s=\s+.*\ss{1}|\*{3}\sOMP_NUM_THREADS\s=\s.*")
# path = "logs_gfortran/log_single_grid_m40_gm40_sweep.txt"
# log_contents = open(path,'r').read()
# 
# for match in log_regex.finditer(log_contents):
#     if "OMP_NUM_THREADS" in match.group():
#         print "Threads = ", int(match.group().strip("*** OMP_NUM_THREADS ="))
#     elif "tick timing" in match.group():
#         print "Time = ", float(match.group().strip("******* tick timing =")[:-1])

def parse_log_file(path,verbose=True):
    
    threads = []
    times = []
    
    # Open contents of log file
    log_contents = open(path,'r').read()
    
    # Loop through regular expression finds
    for match in log_regex.finditer(log_contents):
        if "OMP_NUM_THREADS" in match.group():
            # timings.append({"threads":int(match.group().strip("*** OMP_NUM_THREADS =")),"time":0.0})
            threads.append(int(match.group().strip("*** OMP_NUM_THREADS =")))
            if verbose:
                print "Threads = %s" % threads[-1]
                print "Threads = %s" % timings[-1]["threads"]
        elif "tick timing" in match.group():
            # timings[-1]["time"] = float(match.group().strip("******* tick timing =")[:-1])
            times.append(float(match.group().strip("******* tick timing =")[:-1]))
            if verbose:
                # print "Time = %s" % timings[-1]["time"]
                print "Time = %s" % times[-1]
    
    if not len(threads) == len(times):
        print "Parsing may not have been successful, len(threads) != len(times)."
        print "  threads = %s" % threads
        print "  times = %s" % times
        sys.exit(2)
    
    return threads,times

def parse_time_file(path,verbose=True):
    pass

if __name__ == "__main__":
    import run_thread_tests
    
    verbose = False
        
    log_paths = glob.glob(os.path.join(run_thread_tests.LOG_PATH_BASE,"log*.txt"))
    timing_paths = glob.glob(os.path.join(run_thread_tests.TIME_PATH_BASE,"time*.txt"))
    
    # Setup plots
    import matplotlib.pyplot as plt
    rows = int(math.ceil(len(log_paths) / 2.0))
    fig = plt.figure(figsize=(10,12))
    
    for (i,path) in enumerate(log_paths):
        print os.path.basename(path).strip('log_')[:-4]
        threads,times = parse_log_file(path,verbose=verbose)
        print threads,times

        # Plot this run
        axes = fig.add_subplot(rows,2,i+1)
        axes.plot(threads,times,'or-')
        axes.set_xbound(threads[0]-0.5,threads[-1]+0.5)
        
        # Labeling
        axes.set_title(os.path.basename(path).strip('log_')[:-4])
        axes.set_xlabel('Number of Threads')
        axes.set_xticks(threads)
        axes.set_xticklabels(threads)
        axes.set_ylabel('Time (s)')

    plt.tight_layout()    
    plt.savefig('./log_file_timings.pdf')
        
    if not os.uname()[0] == 'Darwin':
        for path in time_paths:
            print os.path.basename(path).strip('time_')
            print parse_time_file(path,verbose=verbose)
        